# -*- coding: utf-8 -*-
"""Case_Study_WALMART.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/194yCWBsJTW_MXTN1NSgPW7-qo_5Zxa0f

![100.webp](data:image/webp;base64,UklGRhQlAABXRUJQVlA4WAoAAAASAAAAVQEAYwAAQU5JTQYAAAD/////AABBTk1Gdg8AAAAAAAAAAFUBAGMAAGQAAAJWUDggXg8AAHBFAJ0BKlYBZAA+USSPRSOiIZS59SQ4BQSxN3BgANf0CBYHX0YF8R+SXsvVx+zfiH2Df6PoN6c/yP3M+8X5R+j/8f+3fmB8F/8t7Bf0/7AX7Af7z24ehLzDftJ+33uj/4v9qfdV+wnsCfzn/b///sT/Qb/eb04P3V+Hn9yP3a9qjVO/OX9P7bP8Z0yPqaWmYc+3n53hj4AXqf9WOADAB1dGpf3x9gD9Yf9l5S3iBeb+wJ/Jf6z/5PVI0HPUXsL/r71qfRmNAsm6j4Mza6ZNzSPcHJZWQIkJezZQdNAtNT9d5eC63i4myXFcFt5i6tWZJIwtLjHv8gHfb7xcLLHyRDN2OYGFOYfPaUPexMkDRD+k+ssDqxVR6DUSPbR1jArY+fYI4XmEpeBunYsbEx1xRmdp/dMJHSu7MMa/N/ICcgBuGzWVS0VdYbYK1R2NO+Zw10y0m5fGUI++ebTcGhNTq2XxGlw6WXASaB/d4Nt7h7AkmzSAyhh3RR6/ergMvfKCzb7i3P8nEdn07ua4PwiS9kMNRVtiof5Hw9B0YnM/FKRHNOyVwjBgTgBv/vKWR3Lu1A2dqIwv2YM3yEYZRTO1FudMxl5CslsrlsSmCG06T4HhMY2Ih2gZi0hnUtZ3wMSmPd6cEpG+Ob25777O8TIfrqHRnWgr++r3og0DLArIaZBXTE6pKKPxcRpowp0iGM9QJMGGhS0da3Fc0czvTBoE3SSpkoNeaIFpD6QuK4Mza6ZN1HwVAAD+4IIAB200vIgfJ76Oeros9c+J7XlEMjwIrSqlZqGT/4deU4fCLXESCiQbhSQHp4l/uNyKJMDlJ8r8nqjPf53bg8u34PIqHkO2wtZpWzCb99//nJjxnqQPuZecxSsSVR5pkOkDkbCCwxkDFTPavMV1uEd6K53MWH5t/143rD0ZrAiPIW+ttKBOXsBjxm+uF+gjPf/M5eRQscEUVv91Bt+acQg8se8F972E+8RXENxu/8U/jErxel/EAh87IouzhiEgBu6eLajqOTPGT4UELJgktav+Sb3YzfwvN/vOv+dXR+C24+wnnjE0VHxGDkhCzP+wp2URzh7JACdaNLJiZq+zQCQhhDg5X+C/5XnknhN4WXcb4xfHExMba+F7JLGC4hVn3Jqd++wH+xc6Y7oYoCApKt2lBRb/QwDB9JTP+F++fHwZJ1tDVv4xAYpuzsv5CDhQzNJn0zBmGXRpo5OhwR/BvN6huwCzojKgUH7W4OObWbJSZW5Jby3u0HGcAq07V89eT2nypBc+WC0gvJj9eFOm4EKYpTuJckZkkLDXfT1RaQsCI2GRnIVODCIWs9xCVvzCbtWBftTzl2vKOI7BDpDoRNiAz2C23OEbO05jFLVRdn5h8p3Daj8Nhv3/cymn/OOMd8paQ4x4Z84f1aDufaFStat0ebw/EZGDmHssxOgTAX/d/DVXdoWL4W+4rde5RJlEdmBLrNduBKltVdfJYsFK0oo5bQ29t+XzJg3zI91VJznF9J1H4OajcjgBnZrDm4M/nKI/wtsMPSYuHNMjiMXKuzUwA+NM7kt85e7l6il3C5lxpF8W7d8s62cb/BgOt2tSEOkdqXR994mAn/oMOSp5yJIyUjAm1oZQWmH8yYMCwvljUgRbiP10dev+GdiBJ51Pzbs7GymsPp7E1hdJjSxTs06IrZ5Bstg3O17qLBjkV5NqVvMg6CdoKnkThA3YahO57PQ9aNNb7DjlRPzFJbNAqlJNnDJwillnyTFrQcSrVqTsV9+Hjhy0TYGa5wmYanGN2bAcGEKXj9eNIuQBHgpFxepGnAFqsEeiRWYG1esmShkak/A3BC8ToMChIZ+5K23nhi1i4Ob7XXRCT4EOCAHAPwDABO2D4mxgQhNEir2E78s/HB7jPbtOxM7N1TTUkgu3k5+SOTeuJceoxvtPD0j+Wi5KGblhEPTsnVr7mvLTsgQ3jP/VfoFANlf/s64Ca852BfNDOlq/DNKpehi+WVZcAJulb6FMbaUsE9XhC3WEWnXIM/+YRkjSm87Q6uFosbGc5Tu0MuHCp3u/kYfC3dUr+ALeHb/XDwcG8ncS/iFO44lvh3ZLt3Qnd9Yoffhe/93U2L+awLq8CZiha1Lq9JjNO7reDvKONrEjHcX18sxECt2HVPjtKdei4m12PdDAI1yn5QvBdXWSECcXn3kQ1+70IgdFb1SqA2+fza/ZB65O8aGmstkEZW/XdOnQ5kc2GI4w7qLS5gv1oFwDh71L5UZUL6EwpM7dUwMLLdBZrRBpv8KT5vQzgbhDuxCmuQ0jz7kyjc5wF3JrFjt/GfNgTzJPEd1UGkaZucEcXrhmPuXJBoJxhbe8VuRFp4+GwjzurlMxYJI2V/Y9tzJeVXrmr+fo4tFFytrsaNWMT5zD+HV+G5leDYTdvct5BUE+h/CmP7jvqlSrSVvCtvccsOkb8RYwAq2AIppW9+/7Ya3LHwZvJ5OezZ/LlJmvCnnkahvt98PNywtwiMuHsKqmCzMYSt1Eob+O6g8Gx52DtS0qOR4LsN9QNqhSbXogv8QchGcsS6iC0WaREocOBq+yWsIPevZWx+mlthE6uHRr88jWNQ1iSodJf3Y+bv0CEu3/MXsC7V0h/wmPwg464gNiABlDzTrq/e/1Xk89GqIbylQKCq7Dz7JQWmXM46Ci7o4IFNlwZUELxBVv4ZVITPQ0GqrycX0I0OLjkfwTxp94Xt1dYHIPC52/cwP91pH2mwzGGvqiWN6gwtIcxYHF5VBNpYt7GZbd/Z2qtkFpjfREy3a0gpRSJEMn+rpLYnsAyGmdRyjIQVeEf+jXvlhk3nzqyG0zdGx0AD33cwYlyUdgcjpF0dxTAITHhZgkhuXknk9gfNI3Xw/pyqE3/2/eHCj4rp1/4E6E6mGYnypaKfoPgcbXpiciTXehFIyOmkdKfNGiP2wFZg5ABiFZdTzCeN/lE0xS0x7/8hXJLr5kHqERqbD0TwB3ExKFc/cwCWuqe+JKiTBNg2nZlvE0ORxLV6uFhacLkNrDJtodup2dyo9AJNprk5voS/Cgnzp4aSVHNtkVPCtDnLEFsWAGr7dnchHEBfvWpEj89ITAXhdVZNIlFEFzHWf8D9tlEVdo0LL1LIIpJDQyPWaCmvpBzJiBZfqxq73v7B7UM1E6f75KHNoppFCDS2czQ2azjzizfUTzxY4PAEgNJ8mE6K3t6gNze6sOgSxu8xHo519h2akODYU+TVg+eUy6CukDEFptPHwizuHyYSBGuCq9+aghRd40Xuo3hssJaB59s4WxTXVKalNnyEX0vqwbJvwtoAsT5DQCuP5QT+tdzhSjehaPm2C8bYIqdqPgHtupRBqmQX4L1qv2MwkfFviXnxgydj1yHydCjEqxbOFvNHn1gHjYZB26jiXHQeMcBYMGMQwKI2UU5Fv51XQlWrc74Ev4FMH4GA7qOxKdDWcVv01ILal4RaaSjHUzo4Vp3r8CNsb11WYfctoV3pQZ8jA2MoecaHTQkTs4xQuRLrUB3P4iBpBXxfggCRiOfUcnXJg4V/8tJLpcbn8dHhxfmrG6qmf2xZvjhOsUT8stol8gr9p3hpaL5rGT8gnsAJznH6npp2OtKOqrPk9Gm90ZfK0M7/GYvMAcrOrF0PyMkZ1E/yD0ujO90wqmbSVPbXP+jXmVOoSvFhb8kQax1f35b1iDqt6Wa4N7kwcEk926ltN0hCNvyb1bEzr7nv3lzAs8oKZD1E9wJPWYXyPMx8PUxv6wMwpdGKqk4ctH11UVOhbJG6M/lGDfrQd5ZZsxfA/O7d2HCkV23E8iqTTE+h5yVS8gizo6bhr2YocOkQPn3uEGfw/A+1AOgCCqyPkZKwwYEeRkrDXIGrj3fJ7/7sbsarrPrWsm+p/iVhwfE0ZfPcMgfab0bHCVn7yiwmakWRmoY01ZNevxSsHqJhMzCkaD/uWkVxReexhZuh3GzuVAkIpP/2pro8ZJPlfu17j7YD0Kp79C/LSpZIzMsmHdqwLSkVr+Q8DbaXV1lFpW/WKI/+PxeF/StdmmzOZp+Oo+2QGQ/ZHD8B16A0DY+QXusf+Q3hMqwepfq8DddEPA5f+O66QUJLnCTJDJb1JfkbvHrMev9roo2sns63bJuDN0HfCUDEzqpHi/+V+/w20w6D2+gvZltamtqFlmFHcYsozy7WXOzHF77gy7626QDYoPK8ivlMIq+l1Io8cKskCe1bHVuI11LxrzJcca5I5WURMyXitoW3r3KLAAeViyqP5DQLYjq/o6nxCHr+3LCVsNfUmjKfzidIQqwnc95WQtlG5SZFipV62guurBtQESwzYpnv/+NUcqjdaoRXnJ7p2kh16z7546lLrnJB/1z/xhp96MvMsKwEnmYnAJy18PfW2vF35lUoYaFvjV2ar2xaIx40cNlsg4evQWkx6jHaF1fsE9u112SSwU+dOEfikS+xNlayXzu/WeWVD/rjpaLtIIxWwlRFcjlYWN0voYbX2aUg6pUHi5SoVe776kJZpXA1jB0Q+lemlAag50pHQHx0Qxz2SY6ij2jGLWr0M6/vnrNfPJwntUKeC+2qHxXJ6hT4oxdlz/PJvNgijoFdE5BRrCuG/exoKHj91i6U9ddCMrAc4Aa3fQrPHS6LckeA6WRKhOOqw27lW1UFwFgnD4cdl4hqhgB2NFLXkGwRlW3V/40D3UdPsXpeXzzJc+dqYKODX4WkcnH0hXtIRvIT+fndq+JmbNzQ6doleawjQImlV2MGxEqBEmhZjkIj3di78aUUQpoC4ScCLSTrX+BT4wHSAhKVFub7n4W+wNI+BMrJgFhfkY8IHdCDh2E9WGBp/9IGavSbkwWxGfN2iAHJMRwBi5NMK0tGvbTfASgaZOABnjPN55ZQ1l3qG6pyYFyHKp8BckH/Rcp31rL8g/hhmIX/2xj28+IURyLqMWnC2jTUa3xx2h11GtsXuIzbE4w+tb7HgiLasLBaE//uhjFZYfzAC4B50TWAoa1LvmbDbzRWGEjswlPEeYmWGRhW++kCnjblpREDGSj2T4lfbHZU6aIKA0W6tclGcZVFiMNgA6KUnvKIRWjDxd41BVCeEQAlvgiCM1wiZIPQHElG4Zj9iVjgnDxHSvxEXX/T2TMHyhV2Jd9hmm1CzV2Q2RGIkv4qMGW3d1mq8cTiOVKqNUjGnhsWZ1Wuif/gBVRn+eeo7uCACxgAACHAAD/yY78L6SdZrnWpkU0STeMVc/eVbtEjerFw9p4xWdWyhNFM00EeAAAAAAAABBTk1GUgQAAIEAAAUAAEYAAE4AAGQAAABBTFBIPwAAAAEPMP8REcJB20iSVMxqmDW1Ypb9d++6AUT0fwK4rT+zApZWO84ONQPM4IzgYAWvdtzWAM4QVrDSzwpYWu24LQBWUDgg8gMAAFQUAJ0BKkcATwA+TR6MRAMLYsqAAJiWIAzIyKQ3fQ73rIJdyt3f4D2N+I30s/MB0Sv9D6QHUs+hB0wn7jYSj2NY7Oc/HW2s1rUzHnrer0Y/gxx1+DodTPSU4r3ilZfuBCCqKlsStn/YM7Sf6IY6SL9kTyH55pB5k3EeZ/B4WpXPBRtW3BTHj1998Ibt2cUmJLs1liOn6WTn7r5O+RY8cYSASGbo7ZYRwkh6IAD+/lXW+hV/dqY7KJWbxCRbwXY/ecPYavNzjz9rRfYVaMOuzcWLJAuSEv+dnr6+p3y0z01dxk5Bk48I3vOefC0/ZTCzKYMln7nvRddVRbdq4VCilxRbDGaURNIWp0Q1iEHAh7Vkqam71rRA7os6bxYrwpgZs+aVZ5KFGOInA9rKfGtGMguRSf/+/Yv+/vJ89xIlyVG7MuyRpDfeLEj2aXt/Oi8LdLId08vF0VWjvKLz2B6TIDsiJgbA4RAuRINzqZY6AfIUSN7YN3/Q/GNwPtiFGmLBdFqHjh4XTJPIJGBG9rYOKydi+ZUagf1263vov5jZa4h0udIj4ggLQGyfOfiPMr/TOWfTb4/d6o9wce1d+cu/7KHPbS0C/v7ouV4WBv7xZOypc1iJloVnxeU+76UtmsPwyVMFbBhglT+2MtPXgxT5a4fCJ3/OLU3T7UGTkaIatAWX8HKrGU6Cxr7xaKjRLrVC+Jk5qhPp8oXnmVgdcEbVQGkhbqK8gy5yHzq/htBz/uHWPJ4W3ie5N683GDNlFPvGVWl5CaG99XU1YEMXSlx3phqDEEVy9L/f4brvQmEoiDETu9tHVkAcKosaJAE8Ok0+bjvcHyeDLLuHpXXmmWWbfvMf09LBUIVNGUhmeOtbBpCntY10vPaPubPAu8aIWrdL4GuzDPzQobcfBZ9wjie9wnVuq85CSP6foXUc9z22xfE4flA58EVzlh8SIhKJAJ9QHjWtZ5xOkGLggdjBVkcBrX1eEiiMO0X2tvMeNNCHM063nBQdC9V5nA7UUKxrTeHqFrMTMXYbPOfs52kP/yK/FK/S0h6PunDeybwRJQLDVGZRUd+Wb8xOI20Qyz8h5X46iBPZGQbQXh6ARIz7C4mdfCaoWUno/MpBLVW2Z1HjvjAkqS567Oj+VjaPSODqVU/Abhxrwx6DGT5RVMvl494chAjmas4hP+yEbDEYQJwFNzzt3umfPrKaec6RUiPiVjHoxgimVJ99ttkkSiSYsDhiqoxEb3HMAjqS74B0LLcmzKZ6FKj0b1ExvEiT6oaHr7fSInZ0ADBPyoHOgBabtLUMtaLhLhf2u4i/Top7nWO86d1RIKJsTiSXbcCf9LapWcVYcAAAQU5NRjoEAACBAAAFAABGAABOAABkAAAAQUxQSD8AAAABDzD/ERFCISRJzprNm73amn3ODxDR/wlIw3gZkhNSeC4lnHCKH+h/AX8BdwjPpWH8AP4EckJ+DzklpPBcGkYAVlA4INoDAAB0FACdASpHAE8APkkci0QDR5+4gACQlkAM24iko/wHKH8sSh3d4xHiF9K/zD9Fr/L+oB/zOpm3nn9u8JV7If8dj9O9OLnloO13KasLuKy/IZzulNGpe5z97goC9PUbJeqcfOa5TnvjbP835z6Q3Y/WkJ022Y5Qlz5FFnK9mIpxv6Z/OlAf92liXAThto/OwFo2OFOzTRFrhCuwhBrp+70sa9QpN+o2PU8n+74AAP7+iRssfU5GgHWbcYCj6Rkm1VPzOuvqzPvP1WJe6XZ9fH+lHFY1/hsYiE/PCT9Q9Th3Vyqh/wuSLNqGoBHSMj2aqTg5D/hJeTVgKlkUNWeKadk8hYHpIeUPrvSbyQwsJUPUM7PPmeJAT1ogKsbKUS6/4KIAGXWzM1sYztn0bM2YohyWBo1H/zdgJyTKuuD4AflDbfPXjQSf2yMADRtv17iBF9DF2HMRiwRimpTqaWvLLbqZ9BVSy5wSuXhAisNyn89SEJ0Je4/wSaLSG2kmhvSv0j8CjkZe3C5yFaBBLyz3F0Bf2rQoX0231bBSQcppMWpXDoLXk9mWWK/x8JrsCkpiQb9IFKZebWFR+ezHu+TyRd1ewdC3w00njelKwJB+dnzmETrfhozmn7Srje9RO/z2iy9A7i9Z9aPdO6PFpUN2ubkLLDX7BdVszQBhqNgi30ui7t/2KvJWT1yODP/5fE0jX8T976R4/ytpwoP1toCo+4cinUz24jiUefzENdv4yymQr2XmO0d3b8Scy5QxVQ8O87rlH2NrSebG/SZkOexoRjIjZLZabJSOCL7qRK0r0Ck/PvO0xNpmS0jQ0MYh5yFmpETDHAf4/YJk6xXO1MfkndM8AJDI2VIsto3/ciDBpjG2snYR/vAXOWG2cNDPH4boQ4ZjPJfCSqAnnf/VQvxWTYEzyQNyf/EyVhJIKUlq8YUy3d0a4JkGdvitbZRBQqTxSdCi+bmmV0RlzR2CNAMU6MNK9P/tIrbwKo2nQ5WoFNrJYqy0huYw87Jv+ypL6GeiVQopzPOe70BeN2f66/v4MAEPvUSlPfw56g2Nj8xjeCeh1F8P51HTPqmnM+8WTtZ/FDOw5qxYg1a0b2b1uMvzLhZPCoHurEuCtSjKh6r6+jdRs4RhuTKtC4XWO0V4G1nxyOHjn+MqhekVXEA6rB42Jt0NfhZ638gZ103XTTikRFRYa7Ko+0andH7JOO9wHmeMyaQCetkRb+6pQk9Inm3YUo7qeYUvhsUp4Dzf/RIW/VCzEdZZpZSFNjT+FgSgh+ZdVw6RM0HusuC46WC7hxTqA/jJfoQe36MAAAAAAEFOTUYmBAAAgQAABQAARwAATgAAZAAAAEFMUEg1AAAAAQ8w/xERQlHbRlKZhXqYzZ6vGQAR/Z+AakqsIrFdFRZWDTAojoAPbFeD4hBYhQOQK7Fd/QEAVlA4INADAAB0FACdASpIAE8APk0gi0QDH4C6AACYlkANMcX4+3x3H49ESlXWfM/j39RPiN9NzzDdEv/VeoB/uepi3m/9ssIl7MsdfOpjhbQO7/gKQE6OmmlWZPVa+Z7ep1eaPCv6FF/3OJLjWCrSo+VlvcA2jvm/JqtEFNDmg6Hy+1KT/4bZ1HWujbhCyfvlkth8vLb0+CgQqrFPdypttnNIg5JhmvZ7KhIpK50YYva+xxYgAP7+iSTEGcwAcnDCQ2rpwCnzVTmurP8MRkZeyRxYO2eiHwhfgFv9QEWQhvfV2LQOXtUq/OF/WYSFF6HJuUtuqnhaYiplTxppefYTQFZeC0fkUWZgcMvv4btbhi3+5xVj7ysA7zzUhNhXrYmkpsupbR3rwc7j5+o81r7yLXQNln/GFDs3VLZxblSkhue40LnivCILaDVCuokkR0SIn4vZkoeFEih3vMq+YufpITI4LHh9bVP5lvE3x/tcsa59OWcMQkLFuYoAKOBGTjUc0sG1Rbgac9tLHlNJhK4+CtWe7rbwWPpaEh2JO0O1lnrlnjTFnXmOCkh4PZuWDj3eUfusE6bAg2obYazf1HMdR+MOqIXAb2cUj5rEJh7wksdhQrFy3CaGiPvDe4TQCgmCSM3BSZBgbIJxBstJ0/iIs61lAPMlBUpxzG0dqC+M7yvYbRdHckfqyXdI8vyz/U7JW6zsBl1YmUzrWmEdaA/8aF1Eiv2SbniH4LKa6yRLUDrQyd19IUn6bSZ3tleMecn0xmtNQmcoPuo8qritJzzKTC7Cs1dVyHwlJe8/8/c2rLbt3vTY9nN2REr4Tm3zTLaUBbooH+dbBJb5QDbZtECiky0DLh8MQb9FR+TpC+MpI4OA5YBHBjOZoQmTlHcY455enHYuN6lly113nVEEvN0LFhS8JV1+9JGRNAddv6T/HkjiFhqhvXUCKAvc4joXnqZU1OUahYTiAdAuDft2bdenP7EeBns8ICIW9UuwW8bwzu+QDa0Kr1Va+J86O/0rSn2Z0k0A7tAp4uwV9R3inzSz+MAfm/5HzqOmfnDAs0qOnkJY1ul31n8YXj2r+VH54iG9ajH8xI0XmjYIK5GoDDeAmg+F2XlzmRy2jwISXydZ+8KGSfA0Zy6LvbGXddlOKhL5/PfyBN3q74n6cDQuwbbv0hkcvXS4330xlT9RdEyAYjBtYFSbKV9AghX5vk/pq1uoy37qK7zQ+uDHPuhNOK9FW62RtW8g/HTLsDQcpLbPEAcpsK41vqqDk5jHXIDKPj04yIuvnxGn677B06DJSE/Cz29ovQAAAAAAQU5NRkoEAACBAAAFAABGAABOAABkAAAAQUxQSEAAAAABDzD/ERFCISRJzpnNmZ3amn3ODxDR/wlIw7gMU0qY+XMpoYRSfKD/BfQFlDAl/Lk0jA+gT6CUML2HdcyfS8MAVlA4IOoDAADUEwCdASpHAE8APk0gjEQDH1vFgACYlAGUaAEdoxr2JIedyuAeonxQOmx5iOin6AH+g6ljeeP2lwlHqLY+LupFxPhnFiuEad5AcOvBiQwSMAscV6Zjicj0KCMHE6Yd23RH5x0E86/V7Zp3yAOHXWqAmU2fRlEe86asSctxkvyRXWr79A019sPYpPvJv33Zp7cfOHOlOmdwZ7innSCQcUTbNW84gnjwAAD+/lXSQPQlDiq7Aed5W0oIkWAS2VAFQZyc0+TXilvevo1S38rpbpCHd4dlTnNORw4rktk6zSh2tkuq+oshdncvSsKDAYjmCTqZmv7GWv+t00YLAX+cwHg+q+Gfvs9+ABMShkK8ay/EywrNP4tm66bf8+QzVhE3hAtgwn0MZgye0K72ZnvzjZGi0qgqKTcaT1ytW7kKz65Rl0ueszuJE5REgwOW006KssIo7934SWnnq9kRxZeOeaGnSj17rCdTuNP3WVTS4WOmNprtSMMaqJ57tKn0XOd7M0qcfHK5V2i0ObV9X27I+YTUGQvZe0Rizigd0isexxH0DaPWMg5k5tStbx3d+9UZyn0V463l1FB+jz+d3ssun5+xMorMFqJLGILIp9/pG0OdzIFPasVJhVZVlHekpD2ExPp8OFtm5ER3/4/WovOKZTV1ZhZfPXF5SIxlj6RMQzRxC4FKzsLBTfAT5Ko42SJ/GgoTt2FV0eZpp8/Ue6gRlRps+Z31nCrCbrD3yGnuzcKYj7V7+SNP2E/6Yns9Y8gZg+K/xAgqNW3E2EDTHvIrn/n7kv2Uk9SPUrL0rIGvvYzQQyjGMWlFtylb3WM38cVzCkr0mZyNm5nhIcKTrR/nep7EqD5lUtKC3FiQfNMY/WFQAwUPebw5bB3rgL5lb16jaY6hdD7ec082DSv9vtsmccVKAQHuZSf49cQuTQzYOBV67FBtWYYDcbydAxGkEGOBwAJMu0OYHKMjmIgQavmHxuJHl43SNZOowcu5tt6bS3Qcl5GVrJoFdsH/Bi5o5QujqbrVYBDQeHo6f+ptbL1u3JYJtXrd1MJu/+x+wpwW+5SG4qq0X0fKfHpztFf1LbIW37pDn8yD9/Ruq4yGGe1n0EWB3HKaGgraeqo/7JxUTkmS/lc1x4sZXBHRwXH7KIzMBtui217NgHLQcjc06bs56ivP8+0luTDj/FXACl0MoDAHCCO/mGQt+n/4gaJxvv6jiXdImJbs2BjIbs5Gm9hdrem10FnBHS3wfw1e/7G/j3rXZGkPE7XaOXkFxwb/7cjylmNV0doIWlfFB4LURGgLXxf8O4Vpen8VqqArD1SbebjrgZzgBrxP44AAAABBTk1GTgQAAIEAAAUAAEYAAE4AAGQAAABBTFBIPwAAAAEPMP8REUIhJEnOms2bvdqafc4PENH/CUjDeBlySkjhuZRwwim+1/8D/gJOyInwXBrGD+BPICfk91BH4bk0jABWUDgg7gMAAPQTAJ0BKkcATwA+USCMRAMLO8qAAKCWIA0ExDDffEcnrx1IseYcw85bxFulL5h+iJ/rvUA/y3Ucbzh+3WEjWc+b+HM3J5tCspuNwEl2U8bG8JDp7PvYYSKdy3PPWEfkr76kNnG77/TYdfRdcvIVDfeNODKKPdqrHTz4X6e15Y1tZsT/s843Pucn6k62tflW4FguOgIrpcqAef5P1a1aiYYq744iDUwUQAD+/lXWObQfX7kvwCC+zOut7xgIhIhV1i5215B2ENFFBhGkr7M/PqwYU5llh5OS90AHL9dikBkjpTMu5uh6HeQ4ozjfQAJQ3rI+61b6lGuameq3xIbe6jErpH8sryVxnevUwoKl2euC92/4hfTWoNsy6q6NfbSwmnJpt5x138zkOG98QU53bRIMufLgHqHKL1JB0R4WHOqMvkVmULet3uCXedkfe+Ah8WOnFljXf9153HmTPVAssLVMZo0ZOOqHiDe//fXzMHidEmvJD1G+dUP7SVFJhW2aPkBj58e7Lf9eubQznkpMnXSPP98naWhjgNyyQ4HpiIdSrObhTRwANkk0ZQhZP6dSaEuxEXWI7xT/ILYWqaD9U1AFAT7VVVaaQl+M11TnOlX8tFFt8JUvL0oRVGaDjg223ikeSiAxXF3E6gkBmRdwbYPlFiCnUF31OqTGDTATCRAREgRF1Ay2Mj22/Ky40On3jmfJZ3xIm9oGDONNB9+bD/WIir7u4pMMHUJ/sOf7DaX38mkK4dAzBUIdRoOZK7sH/RXYbZc8UGzP6vgP3VuVaQCnNIM4McI8JIPb7Pb+mD3TsN74Saopt+nXq7+2SvXAgP1pKIV8vuvtqZKNx+KFvP6ywMlGuCwrTAfk0zYwNrWt0CzO7nx+5H15N7XMZZJnj5SOlB/+8sgj/W/9uvSypXaGDt/07zEX7KfnIP4Dugba/zkKa/XLN5vW+n33SO/RPzWzUKB7tBUbqq1qYvZcNpzycJjx9leTWjpz+uF8a8LZlk0uVYQmJZjb8aegUs6r4okk+Q2RyREDX9XtTshRS1COuXpJZlaLq01IXJOzw/6Zff6L9fuQhf/KvukSdbYbJnXZ5j8m+AcaCODBxyvmT/yJTK0IH7bvvc1vto7BvJVtSVqYPAxWtZYkY+kaM29Z5AzksSTnVZ1GA7pOhOQWwi2NB7Rf98215OOg9In8clitZteW8IRZ3SX8473A7Cij/M8D/2A3ymOE8Pxi1nCJZlFUcbAqsoSwRxOc9PpKhOQUm+tFGAMHz2d6vnPUv0QXVmNYsgag7B5BHQkznPVDVZgcpQD2qnOH6p/BwDbDdJpjx2zc6Vh/d8+AAAAAAAA=)

<font color='blue'>**Walmart**</font>  is an American multinational retail corporation that operates a chain of supercenters, discount departmental stores, and grocery stores from the United States. Walmart has more than 100 million customers worldwide.

# **PROBLEM STATEMENT**

- **Identifying Purchase Trends:**
  - What factors (e.g., age, gender, city category) significantly influence the purchase amount?
  - Which product categories generate the highest revenue?
- **Customer Segmentation:**
  - How can customers be grouped based on their purchasing behavior?
  - What are the spending patterns of different demographics?
- **Predicting Purchase Behavior:**
  - Can we predict a customer's purchase amount based on their demographics and prior behavior?
- **Optimizing Marketing Strategies:**
  - How can Walmart target specific customer groups for promotions and campaigns to maximize sales?

# **IMPORTING LIBRARIES AND DATASET**
"""

# IMPORTING LIBRARIES

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings("ignore")

# IMPORTING DATASET

!wget "https://d2beiqkhq929f0.cloudfront.net/public_assets/assets/000/001/293/original/walmart_data.csv?1641285094" -O walmart.csv
df = pd.read_csv("walmart.csv")

# A GLIMPSE OF THE WALMART DATASET

df.head(5)

"""# **Observations on shape of data, data types of all the attributes**"""

# SHAPE OF THE DATASET - NO OF ROWS AND COLUMNS

df.shape

print("No of Rows =", df.shape[0])
print("No of Columns =", df.shape[1])

# NAME OF COLUMNS AND THEIR DATATYPE

df.info()

# DESCRIPTIVE STATISTICS SUMMARY OF THE GIVEN DATAFRAME

df.describe(include='all').T

"""# **NULL AND DUPLICATE VALUES**"""

# CALCULATING NUMBER OF NULL VALUES IN ALL COLUMNS

print("-------------------------------------------")
print("No. of Null values in different columns :")
print("-------------------------------------------")
print(df.isnull().sum().sort_values(ascending=False),"\n")

# CHECKING FOR DUPLICATE ROWS

duplicate_rows = df[df.duplicated()]
print("No of Duplicate rows = ",duplicate_rows.shape[0])

"""<font color='blue'>**ANALYSIS**<font>

The analysis implies a clean data without any Null values nor any duplicate values, which eases the process of Data cleaning and Visualisation.

# **OUTLIERS**
"""

# CHECK FOR OUTLIERS

plt.figure(figsize=(6,3))
sns.boxplot(data=df, x="Purchase", color="orange")
plt.title("Boxplot of Purchase Amounts")
plt.xlabel("Purchase Amount")
plt.show()

q1=df.Purchase.quantile(0.25)
q3=df.Purchase.quantile(0.75)
print("Q1,Q3 :",q1,q3)
IQR=q3-q1
print("Inter-Quartile-Range = q3 - q1 =",IQR)
outliers = df[((df.Purchase<(q1-1.5*IQR)) | (df.Purchase>(q3+1.5*IQR)))]

print("Percentage of Outliers in the Dataset : ",len(outliers)/len(df))

"""<font color='blue'>**ANALYSIS**<font>

- **Insight:**
  - The majority of the purchase values are concentrated between 5823.0 and 12054.0.
- **Spread and Variability:**
  - A relatively moderate IQR of 6231.0 suggests that the central portion of the data has a reasonable spread without extreme variability.
- **Low Outlier Percentage:**
  - Since the percentage of outliers is very low (~0.49%), the dataset is relatively clean and doesn't have many extreme values affecting the overall analysis.
"""

df.head()

"""# **Unique Values**"""

print("Number of Distinct User_ids :",df.User_ID.nunique())
print("Number of Distinct Product_ids :",df.Product_ID.nunique())

# % share of all major attributes
columns = ['Gender', 'Age', 'Stay_In_Current_City_Years', 'Marital_Status','City_Category']
df[columns].melt().groupby(['variable', 'value'])[['value']].count()*100/len(df)

"""# **UNIVARIATE and BIVARIATE ANALYSIS**"""

a = df.groupby("Gender")["Purchase"].count()
b = pd.DataFrame(a).reset_index()

fig, axs = plt.subplots(nrows=1,ncols= 2, figsize=(10, 6))
axs[0].pie(
    a,labels=["Female", "Male"],autopct='%.2f%%', colors=["skyblue", "orange"],explode=[0.1, 0.1],radius=1,startangle=180,shadow=True, textprops={"fontsize":10, "color":"black", "weight":"bold"})
axs[0].set_title("GENDER SHARE", fontsize=15, color="black", weight="bold")

sns.barplot(x='Gender', y='Purchase', data=b, ax=axs[1], width=0.5, color='orange')
axs[1].bar_label(axs[1].containers[0], weight="bold")
axs[1].set_xlabel("Gender", weight="bold")
axs[1].set_ylabel("Purchase", weight="bold")
axs[1].set_xticks([0, 1], ["Female", "Male"])
axs[1].set_title("Gender Share in Numbers", weight="bold")

plt.tight_layout()
plt.show()

"""<font color ='blue'>**ANALYSIS**<font>

Males have. asignificant margin in their share of purchase as compared to Females, owing to more product categories in their favour and also owing to the Occupation factor.
"""

c = df.groupby("Marital_Status")["Purchase"].count()
d = pd.DataFrame(c).reset_index()

fig, axs = plt.subplots(1, 2, figsize=(10, 6))

axs[0].pie(c,labels=["Unmarried", "Married"],autopct='%.2f%%',colors=["skyblue", "orange"],explode=[0.1, 0.1],radius=1,startangle=180,shadow=True,textprops={"fontsize":10, "color":"black", "weight":"bold"})
axs[0].set_title("Marital Status SHARE", fontsize=15, color="black", weight="bold")

sns.barplot(x='Marital_Status', y='Purchase', data=d, ax=axs[1], width=0.5, palette=["skyblue", "orange"])
for container in axs[1].containers:
    axs[1].bar_label(container, fmt='%d', weight="bold")
axs[1].set_xlabel("Marital Status", weight="bold")
axs[1].set_ylabel("Purchase", weight="bold")
axs[1].set_xticks([0, 1], ["Unmarried", "Married"])
axs[1].set_title("Marital Status Share in Numbers", weight="bold")

plt.tight_layout()
plt.show()

"""<font color='blue'>**ANALYSIS**<font>

- Marital Status has little impact on the Purchase parity as compared to gender, owing to the differnce of 20% in their respective shares.

- Unmarried Customers leading the race between the two.
"""

a = df.groupby("City_Category")["Purchase"].count()
b = pd.DataFrame(a).reset_index()

fig, axs = plt.subplots(nrows=1,ncols= 2, figsize=(10,6))

axs[0].pie(a,labels=["A", "B", "C"],autopct='%.2f%%',colors=["skyblue", "orange", "green"],explode=[0.1, 0.1, 0.1],radius=1,startangle=180,shadow=True,textprops={"fontsize":10, "color":"black", "weight":"bold"})
axs[0].set_title("City Category Share", fontsize=15, color="black", weight="bold")

sns.barplot(x='City_Category', y='Purchase', data=b, ax=axs[1], width=0.5, palette=["skyblue", "orange", "green"])
for container in axs[1].containers:
    axs[1].bar_label(container, fmt='%d', weight="bold")
axs[1].set_xlabel("City Category", weight="bold")
axs[1].set_ylabel("Purchase", weight="bold")
axs[1].set_title("City Category Share in Numbers", weight="bold")

plt.tight_layout()
plt.show()

"""<font color = ' blue'>**ANALYSIS**<font>

- City B has a major share of Purchase, signalling its size and modernity.
- City A and C donot have any major difference in their contributions, difference margin being only 5%.
"""

a = df.groupby("Age")["Purchase"].count()
b = pd.DataFrame(a).reset_index()

fig, axs = plt.subplots(nrows=1,ncols= 2, figsize=(10,6))

axs[0].pie(a,labels=["0-17 years", "18-25 years", "26-35 years", "36-45 years", "46-51 years", "51-55 years", "55+ years"],explode=[0.1, 0.1, 0.1,0.1, 0.1, 0.1,0.1],autopct='%.2f%%',colors=["skyblue", "orange", "r", "y", "g", "pink", "violet"],radius=1,startangle=180,shadow=False,textprops={"fontsize":10, "color":"black", "weight":"bold"})
axs[0].set_title("Age Group SHARE", fontsize=15, color="black", weight="bold", loc="right")

sns.barplot(x='Age', y='Purchase', data=b, ax=axs[1], width=0.5, color='skyblue')
for container in axs[1].containers:
    axs[1].bar_label(container, fmt='%d', weight="bold")
axs[1].set_xlabel("Age", weight="bold")
axs[1].set_ylabel("Purchase", weight="bold")
axs[1].set_title("Age Group Share in Numbers", weight="bold", pad=10)

plt.tight_layout()
plt.show()

fig, axs = plt.subplots(nrows=1,ncols= 2, figsize=(10, 6))

# Age(Gender) vs Purchase
sns.barplot(data=df, x='Age', y='Purchase', hue="Gender", ax=axs[0],palette={"M": "skyblue", "F": "orange"})
axs[0].set_title("Age vs Purchase by Gender", fontsize=14, weight="bold")
axs[0].set_xlabel("Age", fontsize=12, weight="bold")
axs[0].set_ylabel("Purchase", fontsize=12, weight="bold")
axs[0].legend(title="Gender", fontsize=10)

# Age(Marital) vs Purchase
sns.barplot(data=df, x='Age', y='Purchase', hue="Marital_Status", ax=axs[1],palette={0: "skyblue", 1: "orange"})
axs[1].set_title("Age vs Purchase by Marital Status", fontsize=14, weight="bold")
axs[1].set_xlabel("Age", fontsize=12, weight="bold")
axs[1].set_ylabel("Purchase", fontsize=12, weight="bold")
axs[1].legend(title="Marital Status",fontsize=10)

plt.tight_layout()
plt.show()

"""<font color = 'blue'>**ANALYSIS**<font>

- Age Attribute shows a major tilt towards 26-35 age group who contribute the maximum, followed by 36-45 group.

- The least contribution is from the kids-teen age group of 0-17 yrs, evident from the deciated academics.

- The Age group parameters have no significant efect from factors like Marital Status and Gender evident from the euqal length plots.
"""

fig = plt.figure(figsize=(20,8))
ax=sns.barplot(x='Product_Category',y='Purchase',data=df,width=0.5,color='skyblue',edgecolor='black')
ax.bar_label(ax.containers[0],weight="bold")
plt.xlabel("Product Category",weight="bold")
plt.ylabel("Purchase",weight="bold")
plt.title('Product Category vs Purchase',weight="bold")

plt.show()

gender_data = df.groupby(['Product_Category', 'Gender'])['Purchase'].count().unstack()
marital_data = df.groupby(['Product_Category', 'Marital_Status'])['Purchase'].count().unstack()

fig, axs = plt.subplots(nrows=1, ncols=2, figsize=(18, 6))

gender_data.plot(kind='bar',stacked=True,ax=axs[0],color={"M": "skyblue", "F": "orange"})
axs[0].set_title("Product Category vs Purchase by Gender", fontsize=14, weight="bold")
axs[0].set_xlabel("Product Category", fontsize=12, weight="bold")
axs[0].set_ylabel("Total Purchase", fontsize=12, weight="bold")
axs[0].legend(title="Gender", labels=["Male", "Female"], fontsize=10)

marital_data.plot(kind='bar', stacked=True,ax=axs[1], color={0: "skyblue", 1: "orange"})
axs[1].set_title("Product Category vs Purchase by Marital Status", fontsize=14, weight="bold")
axs[1].set_xlabel("Product Category", fontsize=12, weight="bold")
axs[1].set_ylabel("Total Purchase", fontsize=12, weight="bold")
axs[1].legend(title="Marital Status", labels=["Unmarried", "Married"], fontsize=10)

plt.tight_layout()
plt.show()

purchase_age_category = df.groupby(['Product_Category', 'Age'])['Purchase'].count().unstack()
purchase_age_category.plot(
    kind='bar',
    stacked=True,
    figsize=(15, 6),
    color={'0-17': 'black', '18-25': 'skyblue', '26-35': 'orange', '36-45': 'green', '46-50': 'pink', '51-55': 'r', '55+': 'y'}
)
plt.title("Product Category vs Purchase by Age (Stacked)", fontsize=14, weight="bold")
plt.xlabel("Product Category", fontsize=12, weight="bold")
plt.ylabel("Total Purchase", fontsize=12, weight="bold")
plt.legend(title="Age", fontsize=10)
plt.tight_layout()
plt.show()

"""<font color= 'blue'>**Key Insights:**<font>
- Category 1, 5, and 8 are the top contributors across all demographics, indicating popular product segments.
- **Groups with higher contributions:**
  - Age: 26–35 and 36–45 dominate purchases.
  - Gender: Females contribute more overall.
  - Marital Status: Unmarried individuals are key buyers.
- Categories outside the top three (1, 5, 8) show more balanced but smaller contributions across all demographics.
"""

columns = ['Gender', 'Age', 'Occupation', 'City_Category', 'Stay_In_Current_City_Years', 'Marital_Status']

fig, axs = plt.subplots(nrows=3, ncols=2, figsize=(20, 16))
fig.subplots_adjust(top=1.5)
count = 0
for row in range(3):
    for col in range(2):
        plt.subplot(3, 2, count+1)
        sns.boxplot(data=df, y='Purchase', x=columns[count], hue=columns[count], ax=axs[row, col],palette="Set3" ,legend=False)
        axs[row, col].set_title(f"Purchase vs {columns[count]}", pad=12, fontsize=13)
        count += 1
plt.show()

"""<font color = "blue">**ANALYSIS**<font>

- **Purchase vs. Gender:**
  - Males tend to have slightly higher purchase amounts compared to females, as indicated by the median and range.
- **Purchase vs. Age:**
  - The purchase distribution is fairly similar across age groups, but the median purchase amount is slightly higher in the 26–35 age group compared to others.
- **Purchase vs. Occupation:**
  - There is no significant variation in purchase amounts across occupations. The median and spread appear consistent across different occupation categories.
- **Purchase vs. City Category:**
  - City Category C exhibits the highest median purchase amount, followed by Category B and A. However, all categories have outliers indicating high purchase amounts.
- **Purchase vs. Stay in Current City Years:**
  - The duration of stay in the current city does not seem to greatly affect purchase amounts, with similar medians and spread across all categories.
- **Purchase vs. Marital Status:**
  - Marital status shows a slight variation in purchases. Unmarried individuals (coded as 0) have a slightly lower median purchase amount compared to married individuals (coded as 1).

- **Insights:**
  - There are minor differences in purchase behavior based on gender, age, city category, and marital status.
  - Occupation and stay duration have minimal impact on purchase amounts.
  - There are high-value outliers in all categories, which might represent brand offer purchases at big intervals like 10,000 or 15,000 or 20,000 or frequent buyers.

# **QUESTIONS**

## **1. Are women spending more money per transaction than men? Why or Why not?**
"""

average_spent = df.groupby('Gender')['Purchase'].mean()

print("Average amount spent per transaction by gender:")
print("------------------------------------------------")
print(round(average_spent,2))

"""<font color = "blue">**ANALYSIS**<font>

The dominance of Males over females in the Average Spending owes to factors like product categories which may be men-centric like Harware tools, automobile parts like product categories -1,5,8 which lead the Purchase of Walmart.

##  **2. Confidence intervals and distribution of the mean of the expenses by female and male customers**

### **SAMPLE DISTRIBUTION FOR MALES AND FEMALES**
"""

df.groupby('Gender')['Purchase'].describe()

sns.displot(x='Purchase', bins=25, kde=True,hue='Gender', data=df )
plt.show()

sns.displot(x='Purchase', data=df, bins=25, hue='Gender')
plt.axvline(x=df['Purchase'].mean(), color='r')
plt.axvline(x=df[df['Gender']=='M']['Purchase'].mean(), color='b')
plt.axvline(x=df[df['Gender']=='F']['Purchase'].mean(), color='g')

plt.show()

"""### **SAMPLING FOR FEMALE**"""

female_data = df[df["Gender"]=="F"]
female_mean=female_data["Purchase"].mean()
female_std=female_data["Purchase"].std()
print("Female Purchase amount Mean:",female_mean)
print("Female Purchase amount Standard Deviation:",female_std)

"""<font color = "blue">**RANDOM SAMPLING of DATA FOR FEMALES**<font>

*   **No. of Samples = 1000**
*   **Sample Size = 100,300,600**




"""

female_sample_mean_100=[df[df['Gender']=='F'].sample(100, replace=True)['Purchase'].mean() for i in range(1000)]
female_sample_mean_300=[df[df['Gender']=='F'].sample(300, replace=True)['Purchase'].mean() for i in range(1000)]
female_sample_mean_600=[df[df['Gender']=='F'].sample(600, replace=True)['Purchase'].mean() for i in range(1000)]

#Plotting the 3 sample means

fig, axs = plt.subplots(nrows=1, ncols=3, figsize=(18, 5), sharey=True)

# Plot 1: male_sample_mean_100
sns.histplot(female_sample_mean_100, bins=30, kde=True, ax=axs[0], color="skyblue")
axs[0].set_title("Sample Mean (100)", fontsize=12, weight="bold")
axs[0].set_xlabel("Mean", fontsize=10, weight="bold")
axs[0].set_ylabel("Density", fontsize=10, weight="bold")

# Plot 2: male_sample_mean_300
sns.histplot(female_sample_mean_300, bins=30, kde=True, ax=axs[1], color="orange")
axs[1].set_title("Sample Mean (300)", fontsize=12, weight="bold")
axs[1].set_xlabel("Mean", fontsize=10, weight="bold")
axs[1].set_ylabel("Density", fontsize=10)

# Plot 3: male_sample_mean_600
sns.histplot(female_sample_mean_600, bins=30, kde=True, ax=axs[2], color="green")
axs[2].set_title("Sample Mean (600)", fontsize=12, weight="bold")
axs[2].set_xlabel("Mean", fontsize=10, weight="bold")
axs[2].set_ylabel("Density", fontsize=10)

# Adjust layout
plt.tight_layout()
plt.show()

print("Sample distribution mean for Females (SS = 100) : ",sum(female_sample_mean_100) / len(female_sample_mean_100))
print("Sample distribution mean for Females (SS = 300) : ",sum(female_sample_mean_300) / len(female_sample_mean_300))
print("Sample distribution mean for Females (SS = 600) : ",sum(female_sample_mean_600) / len(female_sample_mean_600))

m=(8714.21 + 8726.53 + 8733.44)/3
print("Sample Distribution Mean for Females = " , m )

"""### **SAMPLING FOR MALES**"""

male_data = df[df["Gender"]=="M"]
male_mean=male_data["Purchase"].mean()
male_std=male_data["Purchase"].std()
print("Male Purchase amount Mean:",male_mean)
print("Male Purchase amount Standard Deviation:",male_std)

"""<font color = "blue">**RANDOM SAMPLING of DATA FOR MALES**<font>

*   **No. of Samples = 1000**
*   **Sample Size = 100,300,600**




"""

male_sample_mean_100=[df[df['Gender']=='M'].sample(100, replace=True)['Purchase'].mean() for i in range(1000)]
male_sample_mean_300=[df[df['Gender']=='M'].sample(300, replace=True)['Purchase'].mean() for i in range(1000)]
male_sample_mean_600=[df[df['Gender']=='M'].sample(600, replace=True)['Purchase'].mean() for i in range(1000)]

#Plotting the 3 sample means

fig, axs = plt.subplots(nrows=1, ncols=3, figsize=(18, 5), sharey=True)

# Plot 1: male_sample_mean_100
sns.histplot(male_sample_mean_100, bins=30, kde=True, ax=axs[0], color="skyblue")
axs[0].set_title("Sample Mean (100)", fontsize=12, weight="bold")
axs[0].set_xlabel("Mean", fontsize=10, weight="bold")
axs[0].set_ylabel("Density", fontsize=10, weight="bold")

# Plot 2: male_sample_mean_300
sns.histplot(male_sample_mean_300, bins=30, kde=True, ax=axs[1], color="orange")
axs[1].set_title("Sample Mean (300)", fontsize=12, weight="bold")
axs[1].set_xlabel("Mean", fontsize=10, weight="bold")
axs[1].set_ylabel("Density", fontsize=10)

# Plot 3: male_sample_mean_600
sns.histplot(male_sample_mean_600, bins=30, kde=True, ax=axs[2], color="green")
axs[2].set_title("Sample Mean (600)", fontsize=12, weight="bold")
axs[2].set_xlabel("Mean", fontsize=10, weight="bold")
axs[2].set_ylabel("Density", fontsize=10)

# Adjust layout
plt.tight_layout()
plt.show()

print("Sample distribution mean for Males (SS = 100) : ",sum(male_sample_mean_100) / len(male_sample_mean_100))
print("Sample distribution mean for Males (SS = 300) : ",sum(male_sample_mean_300) / len(male_sample_mean_300))
print("Sample distribution mean for Males (SS = 600) : ",sum(male_sample_mean_600) / len(male_sample_mean_600))

m=(9451.29 + 9438.36 + 9439.54)/3
print("Sample Distribution Mean for males = " , m )

"""<font color="blue">**COMPARING ORIGINAL MEAN WITH SAMPLE MEANS**<font>

**MALE**
*   <font color = "blue">Original Population Mean</font> = 9437.5
*   <font color = "blue">Sample Distribution Mean</font> = 9443

**FEMALE**
*   <font color = "blue">Original Population Mean</font> = 8734.6
*   <font color = "blue">Sample Distribution Mean</font> = 8725

### **CONFIDENCE INTERVAL CALCULATION**

### **CI FOR FEMALE**
"""

#SAMPLE SIZE 100

standard_deviation_100 = np.std(female_sample_mean_100)
f_sample_mean_100 = np.mean(female_sample_mean_100)

female_upper_limit_100= f_sample_mean_100 + (1.96 * standard_deviation_100)
female_lower_limit_100= f_sample_mean_100 - (1.96 * standard_deviation_100)

print("Lower Limit for Females is {:.2f}".format(female_lower_limit_100))
print("Upper Limit for Females is {:.2f}".format(female_upper_limit_100))
print("--------------------------------------------------------------")

# Boundaries of a 95% confidence interval (CI) for the distribution of sample means - 2.5th and 97.5th percentile

print("2.5th Percentile Boundary:",np.percentile(female_sample_mean_100,2.5))
print("97.5th Percentile Boundary:",np.percentile(female_sample_mean_100,97.5))

#SAMPLE SIZE 300

standard_deviation_300 = np.std(female_sample_mean_300)
f_sample_mean_300 = np.mean(female_sample_mean_300)

female_upper_limit_300= f_sample_mean_300 + (1.96 * standard_deviation_300)
female_lower_limit_300= f_sample_mean_300 - (1.96 * standard_deviation_300)

print("Lower Limit for Females is {:.2f}".format(female_lower_limit_300))
print("Upper Limit for Females is {:.2f}".format(female_upper_limit_300))
print("--------------------------------------------------------------")

# Boundaries of a 95% confidence interval (CI) for the distribution of sample means - 2.5th and 97.5th percentile

print("2.5th Percentile Boundary:",np.percentile(female_sample_mean_300,2.5))
print("97.5th Percentile Boundary:",np.percentile(female_sample_mean_300,97.5))

#SAMPLE SIZE 600

standard_deviation_600 = np.std(female_sample_mean_600)
f_sample_mean_600 = np.mean(female_sample_mean_600)

female_upper_limit_600= f_sample_mean_600 + (1.96 * standard_deviation_600)
female_lower_limit_600= f_sample_mean_600 - (1.96 * standard_deviation_600)

print("Lower Limit for Females is {:.2f}".format(female_lower_limit_600))
print("Upper Limit for Females is {:.2f}".format(female_upper_limit_600))
print("--------------------------------------------------------------")

# Boundaries of a 95% confidence interval (CI) for the distribution of sample means - 2.5th and 97.5th percentile

print("2.5th Percentile Boundary:",np.percentile(female_sample_mean_600,2.5))
print("97.5th Percentile Boundary:",np.percentile(female_sample_mean_600,97.5))

"""### **CI FOR MALE**"""

#SAMPLE SIZE 100

standard_deviation_100 = np.std(male_sample_mean_100)
sample_mean_100 = np.mean(male_sample_mean_100)

male_upper_limit_100= sample_mean_100 + (1.96 * standard_deviation_100)
male_lower_limit_100= sample_mean_100 - (1.96 * standard_deviation_100)

print("Lower Limit for Males is {:.2f}".format(male_lower_limit_100))
print("Upper Limit for Males is {:.2f}".format(male_upper_limit_100))
print("--------------------------------------------------------------")

# Boundaries of a 95% confidence interval (CI) for the distribution of sample means - 2.5th and 97.5th percentile

print("2.5th Percentile Boundary:",np.percentile(male_sample_mean_100,2.5))
print("97.5th Percentile Boundary:",np.percentile(male_sample_mean_100,97.5))

#SAMPLE SIZE 300

standard_deviation_300 = np.std(male_sample_mean_300)
sample_mean_300 = np.mean(male_sample_mean_300)

male_upper_limit_300= sample_mean_300 + (1.96 * standard_deviation_300)
male_lower_limit_300= sample_mean_300 - (1.96 * standard_deviation_300)

print("Lower Limit for Males is {:.2f}".format(male_lower_limit_300))
print("Upper Limit for Males is {:.2f}".format(male_upper_limit_300))
print("--------------------------------------------------------------")

# Boundaries of a 95% confidence interval (CI) for the distribution of sample means - 2.5th and 97.5th percentile

print("2.5th Percentile Boundary:",np.percentile(male_sample_mean_300,2.5))
print("97.5th Percentile Boundary:",np.percentile(male_sample_mean_300,97.5))

#SAMPLE SIZE 600

standard_deviation_600 = np.std(male_sample_mean_600)
sample_mean_600 = np.mean(male_sample_mean_600)

male_upper_limit_600= sample_mean_300 + (1.96 * standard_deviation_600)
male_lower_limit_600= sample_mean_300 - (1.96 * standard_deviation_600)

print("Lower Limit for Males is {:.2f}".format(male_lower_limit_600))
print("Upper Limit for Males is {:.2f}".format(male_upper_limit_600))
print("--------------------------------------------------------------")

# Boundaries of a 95% confidence interval (CI) for the distribution of sample means - 2.5th and 97.5th percentile

print("2.5th Percentile Boundary:",np.percentile(male_sample_mean_600,2.5))
print("97.5th Percentile Boundary:",np.percentile(male_sample_mean_600,97.5))

"""**PLOTTING GRAPHS FOR MALE vs FEMALE CI INTERVALS**

**95% CI**
"""

fig=plt.figure(figsize=(20,8))
sns.histplot(male_sample_mean_100, bins=30, kde=True, color="skyblue", label="Male Sample", alpha=0.6)
sns.histplot(female_sample_mean_100, bins=30, kde=True, color="orange", label="Female Sample", alpha=0.6)

plt.axvline(x=male_lower_limit_100, color="blue", linestyle="--", label=f"Male 95% CI Lower: {male_lower_limit_100:.2f}")
plt.axvline(x=male_upper_limit_100, color="blue", linestyle="--", label=f"Male 95% CI Upper: {male_upper_limit_100:.2f}")
plt.axvline(x=sample_mean_100, color="blue", linestyle="-", label=f"Male Mean: {sample_mean_100:.2f}")

plt.axvline(x=female_lower_limit_100, color="orange", linestyle="--", label=f"Female 95% CI Lower: {female_lower_limit_100:.2f}")
plt.axvline(x=female_upper_limit_100, color="orange", linestyle="--", label=f"Female 95% CI Upper: {female_upper_limit_100:.2f}")
plt.axvline(x=f_sample_mean_100, color="orange", linestyle="-", label=f"Female Mean: {f_sample_mean_100:.2f}")

plt.title("Male vs Female Distribution with 95% Confidence Interval", fontsize=14, weight="bold")
plt.xlabel("Sample Means", fontsize=12, weight="bold")
plt.ylabel("Density", fontsize=12, weight="bold")
plt.legend(fontsize=10, loc="upper left")
plt.show()

"""**SIMILARLY CALCULATING CI for 90% CI FOR BOTH MALE AND FEMALE**"""

#SAMPLE SIZE 300

print("FEMALE:")

# Boundaries of a 90% confidence interval (CI) for the distribution of sample means 5th and 95th percentile

f_l_limit_300=np.percentile(female_sample_mean_300,5)
f_u_limit_300=np.percentile(female_sample_mean_300,95)

print("5th Percentile Boundary:",f_l_limit_300)
print("95th Percentile Boundary:",f_u_limit_300)
print("-------------------------------------------------")

print("MALE:")

# Boundaries of a 90% confidence interval (CI) for the distribution of sample means 5th and 95th percentile

m_l_limit_300 = np.percentile(male_sample_mean_300,5)
m_u_limit_300 = np.percentile(male_sample_mean_300,95)

print("5th Percentile Boundary:",m_l_limit_300)
print("95th Percentile Boundary:",m_u_limit_300)

fig=plt.figure(figsize=(20,8))
sns.histplot(male_sample_mean_300, bins=30, kde=True, color="skyblue", label="Male Sample", alpha=0.6)
sns.histplot(female_sample_mean_300, bins=30, kde=True, color="orange", label="Female Sample", alpha=0.6)

plt.axvline(x=m_l_limit_300, color="blue", linestyle="--", label=f"Male 90% CI Lower: {m_l_limit_300:.2f}")
plt.axvline(x=m_u_limit_300, color="blue", linestyle="--", label=f"Male 90% CI Upper: {m_u_limit_300:.2f}")
plt.axvline(x=sample_mean_300, color="blue", linestyle="-", label=f"Male Mean: {sample_mean_300:.2f}")

plt.axvline(x=f_l_limit_300, color="orange", linestyle="--", label=f"Female 90% CI Lower: {f_l_limit_300:.2f}")
plt.axvline(x=f_u_limit_300, color="orange", linestyle="--", label=f"Female 90% CI Upper: {f_u_limit_300:.2f}")
plt.axvline(x=f_sample_mean_300, color="orange", linestyle="-", label=f"Female Mean: {f_sample_mean_300:.2f}")

plt.title("Male vs Female Distribution with 90% Confidence Interval", fontsize=14, weight="bold")
plt.xlabel("Sample Means", fontsize=12, weight="bold")
plt.ylabel("Density", fontsize=12, weight="bold")
plt.legend(fontsize=10, loc="upper left")
plt.show()

"""**SIMILARLY CALCULATING CI for 99% CI FOR BOTH MALE AND FEMALE**"""

#SAMPLE SIZE 600

print("FEMALE:")

# Boundaries of a 99% confidence interval (CI) for the distribution of sample means 0.5th and 99.5th percentile

f_l_limit=np.percentile(female_sample_mean_600,0.5)
f_u_limit=np.percentile(female_sample_mean_600,99.5)

print("5th Percentile Boundary:",f_l_limit)
print("95th Percentile Boundary:",f_u_limit)
print("-------------------------------------------------")

print("MALE:")

# Boundaries of a 99% confidence interval (CI) for the distribution of sample means 0.5th and 99.5th percentile

m_l_limit = np.percentile(male_sample_mean_600,0.5)
m_u_limit = np.percentile(male_sample_mean_600,99.5)

print("5th Percentile Boundary:",m_l_limit)
print("95th Percentile Boundary:",m_u_limit)

fig=plt.figure(figsize=(20,8))
sns.histplot(male_sample_mean_600, bins=30, kde=True, color="skyblue", label="Male Sample", alpha=0.6)
sns.histplot(female_sample_mean_600, bins=30, kde=True, color="orange", label="Female Sample", alpha=0.6)

plt.axvline(x=m_l_limit, color="blue", linestyle="--", label=f"Male 99% CI Lower: {m_l_limit:.2f}")
plt.axvline(x=m_u_limit, color="blue", linestyle="--", label=f"Male 99% CI Upper: {m_u_limit:.2f}")
plt.axvline(x=sample_mean_600, color="blue", linestyle="-", label=f"Male Mean: {sample_mean_600:.2f}")

plt.axvline(x=f_l_limit, color="orange", linestyle="--", label=f"Female 99% CI Lower: {f_l_limit:.2f}")
plt.axvline(x=f_u_limit, color="orange", linestyle="--", label=f"Female 99% CI Upper: {f_u_limit:.2f}")
plt.axvline(x=f_sample_mean_600, color="orange", linestyle="-", label=f"Female Mean: {f_sample_mean_600:.2f}")

plt.title("Male vs Female Distribution with 99% Confidence Interval", fontsize=14, weight="bold")
plt.xlabel("Sample Means", fontsize=12, weight="bold")
plt.ylabel("Density", fontsize=12, weight="bold")
plt.legend(fontsize=10, loc="upper left")
plt.show()

"""**Confidence Intervals (99% CI):**

- The dashed vertical lines mark the lower and upper bounds of the 99% CI for males and females, with separate colors (blue for males and orange for females).

- For males:
  - 99% CI Lower Bound: ~8947
  - 99% CI Upper Bound: ~9985
- For females:
  - 99% CI Lower Bound: ~8269
  - 99% CI Upper Bound: ~9209

- These intervals provide a range within which the true population means are likely to fall 99% of the time.

- **Means:**
  - The solid vertical lines represent the sample means:
  - Male Mean: ~9439
  - Female Mean: ~8733
    - The male mean is higher than the female mean, suggesting a notable difference in their respective averages.
- **Overlap:**
  - The male and female confidence intervals have minimal overlap, suggesting that the means are statistically different at the 99% confidence level.
"""

fig, axs = plt.subplots(nrows=1, ncols=3, figsize=(24, 8))

# Plot 1: Male vs Female with 99% CI
sns.histplot(male_sample_mean_600, bins=30, kde=True, color="skyblue", label="Male Sample", alpha=0.6, ax=axs[0])
sns.histplot(female_sample_mean_600, bins=30, kde=True, color="orange", label="Female Sample", alpha=0.6, ax=axs[0])
axs[0].axvline(x=m_l_limit, color="blue", linestyle="--", label=f"Male 99% CI Lower: {m_l_limit:.2f}")
axs[0].axvline(x=m_u_limit, color="blue", linestyle="--", label=f"Male 99% CI Upper: {m_u_limit:.2f}")
axs[0].axvline(x=sample_mean_600, color="blue", linestyle="-", label=f"Male Mean: {sample_mean_600:.2f}")
axs[0].axvline(x=f_l_limit, color="orange", linestyle="--", label=f"Female 99% CI Lower: {f_l_limit:.2f}")
axs[0].axvline(x=f_u_limit, color="orange", linestyle="--", label=f"Female 99% CI Upper: {f_u_limit:.2f}")
axs[0].axvline(x=f_sample_mean_600, color="orange", linestyle="-", label=f"Female Mean: {f_sample_mean_600:.2f}")
axs[0].set_title("99% Confidence Interval", fontsize=14, weight="bold")
axs[0].set_xlabel("Sample Means", fontsize=12, weight="bold")
axs[0].set_ylabel("Density", fontsize=12, weight="bold")
axs[0].legend(fontsize=10)

# Plot 2: Male vs Female with 90% CI
sns.histplot(male_sample_mean_300, bins=30, kde=True, color="skyblue", label="Male Sample", alpha=0.6, ax=axs[1])
sns.histplot(female_sample_mean_300, bins=30, kde=True, color="orange", label="Female Sample", alpha=0.6, ax=axs[1])
axs[1].axvline(x=m_l_limit_300, color="blue", linestyle="--", label=f"Male 90% CI Lower: {m_l_limit_300:.2f}")
axs[1].axvline(x=m_u_limit_300, color="blue", linestyle="--", label=f"Male 90% CI Upper: {m_u_limit_300:.2f}")
axs[1].axvline(x=sample_mean_300, color="blue", linestyle="-", label=f"Male Mean: {sample_mean_300:.2f}")
axs[1].axvline(x=f_l_limit_300, color="orange", linestyle="--", label=f"Female 90% CI Lower: {f_l_limit_300:.2f}")
axs[1].axvline(x=f_u_limit_300, color="orange", linestyle="--", label=f"Female 90% CI Upper: {f_u_limit_300:.2f}")
axs[1].axvline(x=f_sample_mean_300, color="orange", linestyle="-", label=f"Female Mean: {f_sample_mean_300:.2f}")
axs[1].set_title("90% Confidence Interval", fontsize=14, weight="bold")
axs[1].set_xlabel("Sample Means", fontsize=12, weight="bold")
axs[1].set_ylabel("Density", fontsize=12, weight="bold")
axs[1].legend(fontsize=10)

# Plot 3: Male vs Female with 95% CI
sns.histplot(male_sample_mean_100, bins=30, kde=True, color="skyblue", label="Male Sample", alpha=0.6, ax=axs[2])
sns.histplot(female_sample_mean_100, bins=30, kde=True, color="orange", label="Female Sample", alpha=0.6, ax=axs[2])
axs[2].axvline(x=male_lower_limit_100, color="blue", linestyle="--", label=f"Male 95% CI Lower: {male_lower_limit_100:.2f}")
axs[2].axvline(x=male_upper_limit_100, color="blue", linestyle="--", label=f"Male 95% CI Upper: {male_upper_limit_100:.2f}")
axs[2].axvline(x=sample_mean_100, color="blue", linestyle="-", label=f"Male Mean: {sample_mean_100:.2f}")
axs[2].axvline(x=female_lower_limit_100, color="orange", linestyle="--", label=f"Female 95% CI Lower: {female_lower_limit_100:.2f}")
axs[2].axvline(x=female_upper_limit_100, color="orange", linestyle="--", label=f"Female 95% CI Upper: {female_upper_limit_100:.2f}")
axs[2].axvline(x=f_sample_mean_100, color="orange", linestyle="-", label=f"Female Mean: {f_sample_mean_100:.2f}")
axs[2].set_title("95% Confidence Interval", fontsize=14, weight="bold")
axs[2].set_xlabel("Sample Means", fontsize=12, weight="bold")
axs[2].set_ylabel("Density", fontsize=12, weight="bold")
axs[2].legend(fontsize=10)

# Adjust layout
plt.tight_layout()
plt.show()

"""<font color = "blue">**ANALYSIS**<font>

*   The mean of this sampling distribution (or in other words, the mean of all the sample means that we had taken), came out pretty close to the original population mean.
*   This demonstrates the first property of the Central Limit theorem. Sampling Distribution Mean ~ Population Mean
*   On average, Male spends more than Female.
*   We noticed that as we increased the sample size, the distribution beomes better , more normal and the deviation is also less.
*   The larger the sample size, the more closely the sampling distribution will follow a normal distribution.

*   **Interpretation of CI Results:**
    - In the 99% CI (left plot), the bounds are widest, indicating a broader range for possible means.
    - The 90% CI (middle plot) has narrower bounds, indicating a more focused range with less uncertainty.
    - The 95% CI (right plot) strikes a balance between width and confidence, which is often used as a standard in statistics.

# **SAMPLE MEAN AND CI ANALYSIS BASED ON MARITAL STATUS**

## **SAMPLE MEAN**
"""

df.head(5)

sns.displot(x='Purchase', bins=25, kde=True,hue='Marital_Status', data=df )

"""<font color = "blue">**ANALYSIS**<font>

The plot shows that both the marital categories almost follow a Normal Distribution.
"""

sns.boxplot(data=df, y='Purchase', x="Marital_Status", hue="Marital_Status", palette="Set3" ,legend=False)

"""<font color = "blue">**ANALYSIS**<font>

The box-plot suggests that there is <font color = "blue"> almost no difference in the medians</font> of **Married and Unmarried poulation distribution**.

Instead of conducting visual-graphical analysis, we can use **Hypothesis Testing** to check if the mean values are significantly different or not.


As we are dealing with medians, the best case scenario for testing is the **Kruskal-Wallis test**, which <font color = "blue">uses median for testing and ignores the outliers for the same</font>.
"""

import scipy.stats as stats

#NULL HYPOTHESIS : Both groups have similar median.
#ALTERNATE HYPOTHESIS : Both groups have different median.

group1=df[df['Marital_Status']==1]['Purchase']
group2=df[df['Marital_Status']==0]['Purchase']


# Perform the Kruskal-Wallis test
stat, p_value = stats.kruskal(group1, group2)

print("Kruskal-Wallis H statistic:", stat)
print("P-value:", p_value)

# Decision
alpha = 0.05
if p_value < alpha:
    print("Reject the null hypothesis: At least one group has different median.")
else:
    print("Fail to reject the null hypothesis: All groups have similar median.")

"""<font color = "blue">**ANALYSIS**<font>

The Null Hypothesis could not be rejected which states that both the groups have equal median as in sync with the graphical analysis.

**CALCULATING MEAN FOR MARITAL STATUS**
"""

group1=df[df['Marital_Status']==1]['Purchase']
group2=df[df['Marital_Status']==0]['Purchase']

married_mean = group1.mean()
unmarried_mean = group2.mean()

print("Unmarried Mean:", unmarried_mean)
print("Married Mean:", married_mean)

"""<font color = "blue">**ANALYSIS**<font>

<font color = 'red'>The means of both the groups - Married and Unmarried tend to be nearly equal,
and the **Kruskal Wallis Test** on the median also signifies the congruency of both the groups.<font>

# **SAMPLE MEAN AND CI ANALYSIS BASED ON AGE GROUPS**
"""

sns.boxplot(data=df, y='Purchase', x="Age", color = 'skyblue' ,legend=False)

"""<font color = "blue">**ANALYSIS**<font>


The visual analysis of AGE GROUP vs PURCHASE clearly states equal contribution from different age groups of population to the Purchase Attribute of Walmart.
"""

a = df.groupby("Age")["Purchase"].mean()
b = pd.DataFrame(a).reset_index()

sns.barplot(x='Age', y='Purchase', data=b, width=0.5, color='skyblue')
for container in axs[1].containers:
    axs[1].bar_label(container, fmt='%d', weight="bold")
axs[1].set_xlabel("Age", weight="bold")
axs[1].set_ylabel("Purchase", weight="bold")
axs[1].set_title("Age Group Share in Numbers", weight="bold", pad=10)

"""<font color = "blue">**ANALYSIS**<font>

The graph clearly implies almost equal mean values for all the age groups, with slight difference in their behaviour.

This can be well understood after calculating Confidence Intervals for all the groups as done below.
"""

# Calculate mean purchase for each age group
age_group_means = df.groupby("Age")["Purchase"].mean()

print("Average Purchase Amount by Age Group:")
print(age_group_means)
print("--------------------------------------------------------------------------------------------")
import scipy.stats as stats

# Define confidence levels
confidence_levels = [0.90, 0.95, 0.99]

# Calculate confidence intervals for each level and each age group
for confidence in confidence_levels:
    print(f"\nConfidence Level: {int(confidence * 100)}%")
    print("--------------------------------------------------------------------------------------------")
    for age_bin, group in df.groupby("Age"):
        sample = group["Purchase"]
        mean = sample.mean()
        sem = stats.sem(sample)
        ci = stats.t.interval(confidence, len(sample)-1, loc=mean, scale=sem)
        print(f"  Age Group: {age_bin}, Mean: {mean:.2f}, {int(confidence*100)}% CI: {ci}")

"""<font color = "blue">**ANALYSIS**<font>

The mean and CI analysis at different level shows that the age group 0-17 yrs is the least contributor to purchase value, while 51-55 yr group contributes to the maximum purchase value owing to the successful life endeavours.

# **SUMMARY**
*   **Age Groups**:
    - The age group 26-35 emerged as the largest contributor to purchases, indicating they are the most active consumer segment.
    - Younger (18-25) and middle-aged (36-45) groups also showed significant purchasing power, while older and the (0-17) age groups contributed less.

*   **Gender Trends**:
    - Male customers accounted for a higher share of purchases compared to female customers.
    - However, females demonstrated high spending potential in specific product categories, suggesting an opportunity to target them with tailored marketing strategies.

*   **Marital Status**:
    - Married individuals contributed more to total purchases than unmarried individuals.
    - This trend suggests that family-oriented campaigns or promotions could be effective.

*   **City Categories**:
    - Customers from Category B cities dominated purchases, followed by Category C and Category A.
    - Walmart may consider strengthening its presence and customer engagement strategies in Category B and C cities to maximize sales.

*   **Product Categories**:
    - Certain product categories like 1,5 and 8 saw significantly higher purchases.
    - Walmart can optimize inventory, pricing, and marketing campaigns around these high-demand categories.
*   **Spending Patterns**:
    - Confidence interval (CI) and mean analyses highlighted that most customer spending fell within predictable ranges, helping in demand forecasting and budget planning.

# **RECOMMENDATIONS**

*   **Age-Focused Marketing:**
    - Devise age-specific campaigns, particularly targeting the 26-35 age group, which represents the most active consumers.
*   **Gender-Specific Promotions:**
    - Tailor promotions for female customers in product categories where their spending is strong.

*   **City-Specific Strategies:**
    - Expand outreach and resources in Category B and C cities, as they drive the majority of sales.
*   **Enhance Product Categories:**
    -  Focus on optimizing the supply  for high-demand product categories while identifying and promoting underperforming ones.

*   **Loyalty Programs:**
    - Introduce or refine loyalty programs to retain married customers and encourage higher spending among younger demographics.

# **CONCLUSION**


This analysis has uncovered valuable insights into customer behavior, preferences, and purchasing trends, which can guide **Walmart** in refining its marketing and operational strategies. By focusing on age-specific promotions, gender-oriented campaigns, and city-specific resource allocation, Walmart can improve customer satisfaction and maximize revenue potential.

Ultimately, the data reveals opportunities for growth in key demographics and product categories, while emphasizing the importance of data-driven decision-making in optimizing business strategies. With these insights, Walmart is well-positioned to better meet customer needs, drive sales, and strengthen its market position in the retail industry.
"""